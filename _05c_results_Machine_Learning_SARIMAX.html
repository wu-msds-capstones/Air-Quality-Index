<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.53">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>c_results_machine_learning_sarimax</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="_05c_results_Machine_Learning_SARIMAX_files/libs/clipboard/clipboard.min.js"></script>
<script src="_05c_results_Machine_Learning_SARIMAX_files/libs/quarto-html/quarto.js"></script>
<script src="_05c_results_Machine_Learning_SARIMAX_files/libs/quarto-html/popper.min.js"></script>
<script src="_05c_results_Machine_Learning_SARIMAX_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_05c_results_Machine_Learning_SARIMAX_files/libs/quarto-html/anchor.min.js"></script>
<link href="_05c_results_Machine_Learning_SARIMAX_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_05c_results_Machine_Learning_SARIMAX_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_05c_results_Machine_Learning_SARIMAX_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_05c_results_Machine_Learning_SARIMAX_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_05c_results_Machine_Learning_SARIMAX_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="ml-time-series-with-sarimax-model" class="level1">
<h1>ML Time Series with SARIMAX Model</h1>
<p>Any time series is decomposed of two things:</p>
<ul>
<li>Seasonality</li>
<li>Trends</li>
</ul>
<p>By the help of <code>statsmodel</code> package we can break the time series into its seasonal pattern and trends. This will helps us to understand the data clearly and will help us to make more sense of the data.</p>
</section>
<section id="decomposing-the-time-series-with-additive-method" class="level1">
<h1>Decomposing the Time Series With Additive Method</h1>
<div id="cell-additive-decomp" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="_05c_results_Machine_Learning_SARIMAX_files/figure-html/additive-decomp-output-1.png" id="additive-decomp" width="656" height="465" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>There are three components to a time series:</p>
<ol type="1">
<li><code>Trend</code>: Trend tells you how things are overall changing<br>
</li>
<li><code>Seasonality</code>: Seasonality shows you how things change within a given period (e.g.&nbsp;year,month, week, day)<br>
</li>
<li><code>Residual</code>: The Error/residual/irregular activity are the anomalies whitch cannot be explained by the trend or the seasonal value</li>
</ol>
<p>In a additive time series, the components add together to make the time series. If you have an increasing trend, you still see roughly the same size peaks and troughs throughout the time series. This is often seen in indexed time series where the absolute value is growing but changes stay relative.</p>
<section id="time-series-prediction" class="level2">
<h2 class="anchored" data-anchor-id="time-series-prediction">Time Series Prediction</h2>
<p>For this project, we have used an extended version of <em>ARIMA</em> model knows as <em>SARIMAX</em> model as we have explained in the methods section. The <em>SARIMAX</em> model is used when the data sets have seasonal cycles. In our dataset concerning air quality/AQI there is a seasonal pattern which we can see in the above visualization.</p>
<p>We need to find the right p,d and q parameters to correctly forecast and predict the AQI value.</p>
<ul>
<li><em>p</em> is the auto-regressive part of the model. It allows us to incorporate the effect of past values into our model.</li>
<li><em>d</em> is the integrated part of the model. This includes terms in the model that incorporate the amount of diferencing (the number of past time points to subtract from the current value) to apply the time series.</li>
<li><em>q</em> is the moving average part of the model. This allows us to set the error of our model as a linear combination of the error values observed at previous time points in the past.</li>
</ul>
<p>We use a tuning technique called <code>grid search method</code> that attempts to compute the optimum values of hyperparameters. We are trying to find the right p,d,q values that would be given as an input to the SARIMAX time series model.</p>
<div id="grid-search" class="cell" data-execution_count="5">
<div class="cell-output cell-output-stdout">
<pre><code>ARIMA(0, 0, 0)x(0, 0, 0, 12) - AIC:969.5419650946665
ARIMA(0, 0, 0)x(0, 0, 1, 12) - AIC:799.0140026908043
ARIMA(0, 0, 0)x(0, 1, 0, 12) - AIC:701.7072455506197
ARIMA(0, 0, 0)x(0, 1, 1, 12) - AIC:568.3211239351035
ARIMA(0, 0, 0)x(1, 0, 0, 12) - AIC:708.2727189545345
ARIMA(0, 0, 0)x(1, 0, 1, 12) - AIC:660.9171130206936
ARIMA(0, 0, 0)x(1, 1, 0, 12) - AIC:596.1563221105039
ARIMA(0, 0, 0)x(1, 1, 1, 12) - AIC:571.8620221843147
ARIMA(0, 0, 1)x(0, 0, 0, 12) - AIC:888.4893265461405
ARIMA(0, 0, 1)x(0, 0, 1, 12) - AIC:754.7451219152275
ARIMA(0, 0, 1)x(0, 1, 0, 12) - AIC:695.0468020327725
ARIMA(0, 0, 1)x(0, 1, 1, 12) - AIC:563.3526496700842
ARIMA(0, 0, 1)x(1, 0, 0, 12) - AIC:708.3487691701486
ARIMA(0, 0, 1)x(1, 0, 1, 12) - AIC:655.8968840891383
ARIMA(0, 0, 1)x(1, 1, 0, 12) - AIC:598.1490374699148
ARIMA(0, 0, 1)x(1, 1, 1, 12) - AIC:566.3367865157978
ARIMA(0, 1, 0)x(0, 0, 0, 12) - AIC:769.1876196189784
ARIMA(0, 1, 0)x(0, 0, 1, 12) - AIC:681.4253047727481
ARIMA(0, 1, 0)x(0, 1, 0, 12) - AIC:740.3973501203114
ARIMA(0, 1, 0)x(0, 1, 1, 12) - AIC:606.0067883430007
ARIMA(0, 1, 0)x(1, 0, 0, 12) - AIC:688.9276375883021
ARIMA(0, 1, 0)x(1, 0, 1, 12) - AIC:683.2372837276466
ARIMA(0, 1, 0)x(1, 1, 0, 12) - AIC:637.9760649104885
ARIMA(0, 1, 0)x(1, 1, 1, 12) - AIC:607.9989487123431
ARIMA(0, 1, 1)x(0, 0, 0, 12) - AIC:717.0512101206406
ARIMA(0, 1, 1)x(0, 0, 1, 12) - AIC:636.373429528529
ARIMA(0, 1, 1)x(0, 1, 0, 12) - AIC:692.512410906277
ARIMA(0, 1, 1)x(0, 1, 1, 12) - AIC:559.6920424480529
ARIMA(0, 1, 1)x(1, 0, 0, 12) - AIC:650.5293595230056
ARIMA(0, 1, 1)x(1, 0, 1, 12) - AIC:638.1908637932411
ARIMA(0, 1, 1)x(1, 1, 0, 12) - AIC:594.940391452659
ARIMA(0, 1, 1)x(1, 1, 1, 12) - AIC:562.5484300875305
ARIMA(1, 0, 0)x(0, 0, 0, 12) - AIC:775.150570595756
ARIMA(1, 0, 0)x(0, 0, 1, 12) - AIC:688.1982167211085
ARIMA(1, 0, 0)x(0, 1, 0, 12) - AIC:702.425519762607
ARIMA(1, 0, 0)x(0, 1, 1, 12) - AIC:570.1689904036024
ARIMA(1, 0, 0)x(1, 0, 0, 12) - AIC:688.2931195730088
ARIMA(1, 0, 0)x(1, 0, 1, 12) - AIC:662.6749372683774
ARIMA(1, 0, 0)x(1, 1, 0, 12) - AIC:590.7883988000217
ARIMA(1, 0, 0)x(1, 1, 1, 12) - AIC:573.825547011459
ARIMA(1, 0, 1)x(0, 0, 0, 12) - AIC:725.2611476282008
ARIMA(1, 0, 1)x(0, 0, 1, 12) - AIC:644.4595774810737
ARIMA(1, 0, 1)x(0, 1, 0, 12) - AIC:696.6355146715679
ARIMA(1, 0, 1)x(0, 1, 1, 12) - AIC:565.337721591011
ARIMA(1, 0, 1)x(1, 0, 0, 12) - AIC:651.3742765976529
ARIMA(1, 0, 1)x(1, 0, 1, 12) - AIC:657.7255114881699
ARIMA(1, 0, 1)x(1, 1, 0, 12) - AIC:592.7702867201957
ARIMA(1, 0, 1)x(1, 1, 1, 12) - AIC:567.3861300859227
ARIMA(1, 1, 0)x(0, 0, 0, 12) - AIC:750.4532664961456
ARIMA(1, 1, 0)x(0, 0, 1, 12) - AIC:665.693748389872
ARIMA(1, 1, 0)x(0, 1, 0, 12) - AIC:720.7807876037391
ARIMA(1, 1, 0)x(0, 1, 1, 12) - AIC:588.6301637485213
ARIMA(1, 1, 0)x(1, 0, 0, 12) - AIC:665.7141239363682
ARIMA(1, 1, 0)x(1, 0, 1, 12) - AIC:667.6890275833365
ARIMA(1, 1, 0)x(1, 1, 0, 12) - AIC:611.4437482645567
ARIMA(1, 1, 0)x(1, 1, 1, 12) - AIC:590.6185673644065
ARIMA(1, 1, 1)x(0, 0, 0, 12) - AIC:717.3211552781574
ARIMA(1, 1, 1)x(0, 0, 1, 12) - AIC:636.7110296932944
ARIMA(1, 1, 1)x(0, 1, 0, 12) - AIC:693.1696490581699
ARIMA(1, 1, 1)x(0, 1, 1, 12) - AIC:561.5301944999834
ARIMA(1, 1, 1)x(1, 0, 0, 12) - AIC:643.9735168529521
ARIMA(1, 1, 1)x(1, 0, 1, 12) - AIC:638.640931561371
ARIMA(1, 1, 1)x(1, 1, 0, 12) - AIC:588.5992832053371
ARIMA(1, 1, 1)x(1, 1, 1, 12) - AIC:564.5468753697722</code></pre>
</div>
</div>
<p>We have to find the lowest AIC values which would have the best corresponding p,d,q values to have the best forecast of AQI values.</p>
</section>
</section>
<section id="summary-of-sarimax" class="level1">
<h1>Summary of SARIMAX</h1>
<section id="print-the-summary-which-includes-aic" class="level2">
<h2 class="anchored" data-anchor-id="print-the-summary-which-includes-aic">Print the summary which includes AIC</h2>
<div id="mod-fit" class="cell" data-execution_count="6">
<div class="cell-output cell-output-stdout">
<pre><code>==============================================================================
                 coef    std err          z      P&gt;|z|      [0.025      0.975]
------------------------------------------------------------------------------
ar.L1          0.0483      0.306      0.158      0.875      -0.551       0.648
ma.L1         -1.0000    924.523     -0.001      0.999   -1813.031    1811.031
ma.S.L12      -1.0000   2355.498     -0.000      1.000   -4617.692    4615.692
sigma2       134.1503   3.35e+05      0.000      1.000   -6.57e+05    6.57e+05
==============================================================================</code></pre>
</div>
</div>
</section>
</section>
<section id="how-fit-the-sarimax-model" class="level1">
<h1>How Fit the SARIMAX model</h1>
<section id="plot-diagnostics" class="level2">
<h2 class="anchored" data-anchor-id="plot-diagnostics">Plot Diagnostics</h2>
<div id="extract-aic-value-plot" class="cell" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>The AIC value is: 561.5301944999834</code></pre>
</div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/wu-msds-capstones/Air-Quality-Index/blob/main/images/plot-diag.png?raw=true" class="img-fluid figure-img"></p>
<figcaption>Plot Diag</figcaption>
</figure>
</div>
</section>
</section>
<section id="train-and-test" class="level1">
<h1>Train and Test</h1>
<p>Rigorous validation is paramount to establishing the model’s reliability and practical application. To ensure the model’s generalizability, we will employ a train-test split. This approach safeguards against overfitting by exposing the model to unseen data, allowing for a more accurate assessment of its predictive capabilities.</p>
<p>By partitioning the dataset, we can:</p>
<ul>
<li>Evaluate performance: Measure the model’s accuracy on unseen data.</li>
<li>Detect overfitting: Identify discrepancies between training and testing performance.</li>
<li>Assess generalization: Determine the model’s ability to handle new data.</li>
<li>Quantify reliability: Calculate confidence intervals for prediction accuracy.</li>
<li>Iteratively improve: Use insights to refine the model.</li>
</ul>
<p>This rigorous process underpins the credibility and utility of our research findings.</p>
<p>To split the data, we follow the recommended <code>70:30</code> ratio, 70% of the data is the training data, and 30% of the data is the testing data.</p>
<p>Once the model is created, predicted values are generated using the .get_prediction() method, with datetime as input</p>
<p>The graph indicates overlapping patterns in the testing and training data, suggesting strong potential for the forecasting model’s performance.</p>
<div id="cell-plot-prediction" class="cell" data-execution_count="12">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="_05c_results_Machine_Learning_SARIMAX_files/figure-html/plot-prediction-output-1.png" id="plot-prediction" width="1134" height="583" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>To facilitate comparison of true and predicted test values, we will create a separate DataFrame. Mean Error Estimation will be used for analysis.</p>
<p>To evaluate model performance, we calculate the MSE</p>
<div id="calculate-mse" class="cell" data-execution_count="14">
<div class="cell-output cell-output-stdout">
<pre><code>The Mean Squared Error of our forecasts is 1.41</code></pre>
</div>
</div>
<section id="forecasting-future-values" class="level2">
<h2 class="anchored" data-anchor-id="forecasting-future-values">Forecasting Future Values</h2>
<p>As we conclude our modeling process, we generate predictions for the next 7 data points:</p>
<ol type="1">
<li><p><strong>Model Information</strong>: The <code>result</code> variable contains our fitted model’s details.</p></li>
<li><p><strong>Forecasting Method</strong>: We use the <code>.get_forecast()</code> method on our model results.</p></li>
<li><p><strong>Prediction Generation</strong>: This method analyzes observed patterns in our data to project future values.</p></li>
<li><p><strong>Output</strong>: We obtain forecasts for the next 7 time points, representing predicted air quality levels.</p></li>
</ol>
<p>This step transforms our analytical work into actionable insights for air quality management.</p>
</section>
<section id="visualizing-our-results-the-culmination-of-our-analysis" class="level2">
<h2 class="anchored" data-anchor-id="visualizing-our-results-the-culmination-of-our-analysis">Visualizing Our Results: The Culmination of Our Analysis</h2>
<p>The final and crucial step of our project is the creation of a comprehensive plot that encapsulates our complex analysis. This visualization serves as the key to understanding and interpreting our findings.</p>
<section id="interpreting-the-forecast-plot" class="level3">
<h3 class="anchored" data-anchor-id="interpreting-the-forecast-plot">Interpreting the Forecast Plot</h3>
<p>Our plot consists of several key elements:</p>
<ol type="1">
<li><strong>Observed Values (Blue Line)</strong>
<ul>
<li>Represents the actual, historical air quality measurements</li>
<li>Provides a baseline for comparing our predictions</li>
</ul></li>
<li><strong>Forecasted Values (Orange Line)</strong>
<ul>
<li>Depicts the future air quality levels predicted by our SARIMAX Time Series Model</li>
<li>Allows us to visualize potential trends and patterns in air quality</li>
</ul></li>
<li><strong>Confidence Interval (Shaded Region)</strong>
<ul>
<li>The shaded area around the forecast line represents the 95% Confidence Interval (CI)</li>
<li>Indicates the range within which we can be 95% confident that the true future values will fall</li>
<li>Wider intervals suggest greater uncertainty in the prediction</li>
</ul></li>
</ol>
<p>This visual representation not only summarizes our extensive data analysis but also provides a powerful tool for understanding potential future air quality trends. It bridges the gap between complex statistical models and actionable insights, making our findings accessible and meaningful to a broader audience.</p>
<div id="cell-plot-forecast" class="cell" data-execution_count="16">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="_05c_results_Machine_Learning_SARIMAX_files/figure-html/plot-forecast-output-1.png" id="plot-forecast" width="1118" height="583" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>